# 자료 구조 & 알고리즘
---
## 2022-07-21
### 주제 : [자료 구조](https://dev-coco.tistory.com/159)
### QNA
<details>
<summary> 해시 테이블(Hash Table)과 시간 복잡도에 대해 설명해주세요.</summary>

## Hash Table    
- 해시 테이블은 (Key, Value)로 데이터를 저장하는 자료구조 중 하나로 빠르게 데이터를 검색할 수 있는 자료구조입니다.
- 빠른 검색 속도를 제공하는 이유는 내부적으로 배열(버킷)을 사용하여 데이터를 저장하기 때문입니다.
- 각 Key값은 해시함수에 의해 고유한 index를 가지게 되어 바로 접근할 수 있으므로 평균 O(1)의 시간 복잡도로 데이터를 조회합니다. 
- 하지만 index값이 충돌이 발생한 경우 Chanining에 연결된 리스트들까지 검색해야 하므로 O(N)까지 증가할 수 있습니다.
</details>

<details>
<summary>RBT(Red-Black Tree)에 대해 설명해주세요.</summary>

## RBT
- RBT(Red-Black Tree)는 BST를 기반으로 하는 트리 형식 자료구조
- RBT는 BST의 삽입, 삭제 연산 과정에서 발생할 수 있는 문제점을 해결하기 위해 만듦
- BST를 기반으로 하기 때문에 당연히 BST의 특징을 모두 가짐.
- 노드의 child가 없을 경우 child를 가리키는 포인터는 NIL 값을 저장한다. 이러한 NIL들을 leaf node로 간주한다.
- 모든 노드를 빨간색 또는 검은색으로 색칠하며, 연결된 노드들은 색이 중복되지 않는다. 

</details>

<details>
<summary> RBT 조건 5가지 </summary>

## RBT 조건 5가지
1. 모든 노드는 빨간색 혹은 검은색이다.
2. 루트 노드는 검은색이다.
3. 모든 리프 노드(NIL)들은 검은색이다. (NIL : null leaf, 자료를 갖지 않고 트리의 끝을 나타내는 노드)
4. 빨간색 노드의 자식은 검은색이다. == No Double Red(빨간색 노드가 연속으로 나올 수 없다)
5. 모든 리프 노드에서 Black Depth는 같다. == 리프노드에서 루트 노드까지 가는 경로에서 만나는 검은색 노드의 개수가 같다.
</details>


---
## 2022-07-28
### 주제 : [자료 구조](https://gmlwjd9405.github.io/2017/10/01/basic-concepts-of-development-algorithm.html)
### QNA
<details>
<summary>합병 정렬에대해서 설명해주세요</summary>

## 합병 정렬
- 존 폰 노이만(John von Neumann)’이라는 사람이 제안한 방법
- 일반적인 방법으로 구현했을 때 이 정렬은 안정 정렬 에 속하며, 분할 정복 알고리즘의 하나 이다.
- 분할 정복(divide and conquer) 방법
    - 문제를 작은 2개의 문제로 분리하고 각각을 해결한 다음, 결과를 모아서 원래의 문제를 해결하는 전략이다.
    - 분할 정복 방법은 대개 순환 호출을 이용하여 구현한다.
- 과정 설명
1. 리스트의 길이가 0 또는 1이면 이미 정렬된 것으로 본다. 
2. 그렇지 않은 경우에는 정렬되지 않은 리스트를 절반으로 잘라 비슷한 크기의 두 부분 리스트로 나눈다.
3. 각 부분 리스트를 재귀적으로 합병 정렬을 이용해 정렬한다.
4. 두 부분 리스트를 다시 하나의 정렬된 리스트로 합병한다.

### 단점 
1. 만약 레코드를 배열(Array)로 구성하면, 임시 배열이 필요하다.
2. 제자리 정렬(in-place sorting)이 아니다.
레크드들의 크기가 큰 경우에는 이동 횟수가 많으므로 매우 큰 시간적 낭비를 초래한다.

### 장점 

1. 안정적인 정렬 방법
2. 데이터의 분포에 영향을 덜 받는다. 즉, 입력 데이터가 무엇이든 간에 정렬되는 시간은 동일하다. (O(nlog₂n)로 동일)
3. 만약 레코드를 연결 리스트(Linked List)로 구성하면, 링크 인덱스만 변경되므로 데이터의 이동은 무시할 수 있을 정도로 작아진다.
    
    → 제자리 정렬(in-place sorting)로 구현할 수 있다.
    따라서 크기가 큰 레코드를 정렬할 경우에 연결 리스트를 사용한다면, 합병 정렬은 퀵 정렬을 포함한 다른 어떤 졍렬 방법보다 효율적이다.

</details>
<details>
<summary> 셀 정렬에 대해서 설명해주세요 </summary>

 ## 셀 정렬
 - Donald L. Shell’이라는 사람이 제안한 방법으로, 삽입정렬을 보완한 알고리즘이다.
 - 삽입 정렬이 어느 정도 정렬된 배열에 대해서는 대단히 빠른 것에 착안
 - 삽입 정렬의 최대 문제점: 요소들이 삽입될 때, 이웃한 위치로만 이동
 - 즉, 만약 삽입되어야 할 위치가 현재 위치에서 상당히 멀리 떨어진 곳이라면 많은 이동을 해야만 제자리로 갈 수 있다.
 - 삽입 정렬과 다르게 셸 정렬은 전체의 리스트를 한 번에 정렬하지 않는다.
 
 과정 설명
 
 1. 먼저 정렬해야 할 리스트를 일정한 기준에 따라 분류
 2. 연속적이지 않은 여러 개의 부분 리스트를 생성
 3. 각 부분 리스트를 삽입 정렬을 이용하여 정렬
 4. 모든 부분 리스트가 정렬되면 다시 전체 리스트를 더 적은 개수의 부분 리스트로 만든 후에 알고리즘을 반복
 5. 위의 과정을 부분 리스트의 개수가 1이 될 때까지 반복
 
 ## 장점
 
 1. 연속적이지 않은 부분 리스트에서 자료의 교환이 일어나면 더 큰 거리를 이동한다. 따라서 교환되는 요소들이 삽입 정렬보다는 최종 위치에 있을 가능성이 높아진다.
 2. 부분 리스트는 어느 정도 정렬이 된 상태이기 때문에 부분 리스트의 개수가 1이 되게 되면 셸 정렬은 기본적으로 삽입 정렬을 수행하는 것이지만 삽입 정렬보다 더욱 빠르게 수행된다.
 3. 알고리즘이 간단하여 프로그램으로 쉽게 구현할 수 있다.
</details>

<details>
<summary>버킷정렬과 버킷정렬의 시간복잡도에 대해서 설명해주세요</summary>

## 버킷 정렬
버킷 정렬은 데이터의 키 값을 분석하여 **같은 값끼리 그 순서에 맞는 버킷에 분배했다가 버킷의 순서대로 레코드를 꺼내어 정렬하는 방법**으로 입력이 일정 범위에 걸쳐 **균등 분포**에 가까울 때 유용하다.
데이터의 분포가 균등하다면 각 버킷에는 1~2개의 요소만 속해 있을 것이므로 이 값들만 있는 버킷 하나를 정렬하는 데 필요한 시간 복잡도는 O(1)이 될 것이다. 이를 n개의 머킷에 모두 수행한다면 전체적인 시간 복잡도는 O(n)이 될것이다. 따라서 버킷 정렬의 **평균 시간 복잡도는 O(n)**이다. 또한 모든 원소가 하나의 버킷에 들어가는 경우가 최악의 경우이며 이때의 시간 복잡도는 버킷 내부를 정렬하는 알고리즘에 따라 결정된다. 주로 삽입 정렬이 이용되므로 **최악의 시간복잡도는 O(n^2)**이라고 할 수 있다.

[버킷 정렬 wiki](https://ko.wikipedia.org/wiki/버킷_정렬)
[참고](https://ratsgo.github.io/data%20structure&algorithm/2017/10/18/bucketsort/)

</details>

---
## 2022-08-04
### 주제 : [정렬, 탐색, MST, 최단 경로, union-find](https://gmlwjd9405.github.io/2017/10/01/basic-concepts-of-development-algorithm.html)
### QNA
<details>
<summary> dfs와 bfs 차이점, 각각 언제 사용하면 좋은지</summary>
    
## dfs

- 루트 노드(혹은 다른 임의의 노드)에서 시작해서 다음 분기(branch)로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방법
- 넓게 탐색하기 전에 깊게 탐색하는 방법
- 단순 검색 속도는 너비 우선 탐색보다 느림
- 재귀를 이용하거나 Stack을 이용한다.
- 전위 순회(Pre-Order Traversals)를 포함한 다른 형태의 트리 순회는 모두 DFS의 한 종류이다.
- 어떤 노드를 방문했었는지 여부를 반드시 검사하지 않으면 무한 루프에 빠질 수 있다.

## bfs

- 루트 노드(혹은 다른 임의의 노드)에서 시작해서 인접한 노드를 먼저 탐색하는 방법
- 깊게(deep) 탐색하기 전에 넓게(wide) 탐색하는 것이다.
- 재귀적이지 않다.
- 큐를 사용한다. FIFO 원칙으로 탐색
- 어떤 노드를 방문했었는지 여부를 반드시 검사하지 않으면 무한 루프에 빠질 수 있다.

## 시간 복잡도
인접 리스트 : O(N+E)
인접 행렬 : O(N²)

## dfs와 bfs를 활용한 문제 유형

1. 모든 정점을 방문하는 것이 중요한 경우 : bfs/dfs 중 편한 것
2. 경로의 특징을 저장해야하는 경우 : dfs
3. 최단거리를 구하는 문제 : bfs
4. 검색 대상 그래프가 정말 큰 경우 : dfs
5. 검색 대상의 규모가 크지 않고 시작 지점으로부터 원하는 대상이 멀지 않은 경우 : bfs

[출처](https://devuna.tistory.com/32)
</details>

<details>    
<summary> Prim의 알고리즘과 Kruscal 알고리즘을 비교하여 설명해주세요</summary>

## Kruskal
탐욕적인 방법(greedy method) 을 이용하여 네트워크(가중치를 간선에 할당한 그래프)의 모든 정점을 최소 비용으로 연결하는 최적 해답을 구하는 것

### Kruskal 알고리즘의 동작

1. 그래프의 간선들을 가중치의 오름차순으로 정렬한다.
2. 정렬된 간선 리스트에서 순서대로 사이클을 형성하지 않는 간선을 선택한다.
-> 즉, 가장 낮은 가중치를 먼저 선택한다.
-> 사이클을 형성하는 간선을 제외한다.
1. 해당 간선을 현재의 MST(최소 비용 신장 트리)의 집합에 추가한다.

## Prim
시작 정점에서부터 출발하여 신장트리 집합을 단계적으로 확장해나가는 방법

### Prim 알고리즘의 동작

1. 시작 단계에서는 시작 정점만이 MST(최소 비용 신장 트리) 집합에 포함된다.
2. 앞 단계에서 만들어진 MST 집합에 인접한 정점들 중에서 최소 간선으로 연결된 정점을 선택하여 트리를 확장한다.
->즉, 가장 낮은 가중치를 먼저 선택한다.
1. 위의 과정을 트리가 (N-1)개의 간선을 가질 때까지 반복한다.
</details>

<details>
<summary> 자료 구조에 따른 Prim 알고리즘의 성능 </summary>
1. 인접행렬 : O(V^2)
2. 이진 힙과 인접 리스트 : O((V+E)logV) = O(ElogV)
3. 피보나치 힙과 인접 리스트 : O(E+VlogV)

*V-1 ≤ E ≤ V(V-1)/2*

[출처](https://gamedevlog.tistory.com/47)
[피보나치 힙](https://ko.wikipedia.org/wiki/%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98_%ED%9E%99)

</details>

---
## 2022-08-11
### 주제 : Stack, Queue 구현 (Live Coding)
### QNA 생략
---